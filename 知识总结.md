## try-catch
- 普通的错误获取：

  ```js
    // 错误的上抛出
    // 在嵌套try-catch中十分重要，如下，三层调用关系（底层 → 中间层 → 上层），每层都可能抛出错误，如果没有cause: error，中间每一次捕获错误后，继续上抛错误都会重新new Error一个新的错误信息，而原始错误数据会丢失，所以经过层级覆盖后，底层操作的错误会被覆盖，最终追溯错误只能到上层业务的函数层级
    // 1. 底层函数（原始错误发生地）
    function底层操作() {
      throw new Error("数据库连接失败"); // 根因错误
    }

    // 2. 中间层函数（处理底层结果）
    function中间处理() {
      try {
        底层操作();
      } catch (err) {
        // 无 cause：仅抛出新错误，原始错误被丢弃
        throw new Error("数据处理失败");
      }
    }

    // 3. 上层业务函数（调用中间层）
    function上层业务() {
      try {
        中间处理();
      } catch (err) {
        // 无 cause：再次抛出新错误，中间层错误被丢弃
        throw new Error("业务执行失败");
      }
    }

    // 最终调用
    try {
      上层业务();
    } catch (err) {
      console.log(err.message); // 只能看到 "业务执行失败"
      console.log(err.stack);   // 堆栈仅显示上层业务的错误位置
      // 完全无法知道底层的 "数据库连接失败" 根因
    }
  ```

- 2.深层错误处理

  ```js
  // 二、核心好处
  // 保留完整错误链路避免原始错误信息丢失。例如，业务层错误（“订单创建失败”）可能由底层错误（“数据库连接失败”）导致，通过 cause 可以追溯到根因，方便调试。
  // 区分错误责任边界上层代码可以专注于处理业务逻辑错误，同时通过 cause 向下传递底层技术错误（如网络、数据库错误），明确错误发生的层次。
  // 简化错误日志与监控日志系统可以通过遍历 cause 链，记录完整的错误堆栈，快速定位问题（例如：前端报错 → 后端接口错误 → 数据库查询错误）。
  // 底层函数：模拟数据库操作
  function queryDB() {
    throw new Error("SQL语法错误"); // 原始错误
  }

  // 中间层：处理数据逻辑
  function processData() {
    try {
      queryDB();
      // throw new Error('processData内业务代码出错了')
    } catch (dbErr) {
      // 包装为数据处理错误，附加原始数据库错误
      // 来自底层的原始错误不会被覆盖（无论层级） 而且本层级正常报错
      throw new Error("数据解析失败", { cause: dbErr });
    }
  }

  // 上层：业务逻辑
  try {
    processData();
    throw new Error("上层内业务代码出错了");
  } catch (bizErr) {
    // 接受非顶层业务的报错
    if (bizErr.cause) {
      console.error("业务错误:", bizErr.message); // 数据解析失败
      console.error("技术根因:", bizErr.cause.message); // SQL语法错误
      console.error("原始错误堆栈:", bizErr.cause.stack); // 可查看底层错误的堆栈信息
    } else {
      // 接受顶层业务的报错
      console.log("顶层业务报错", bizErr);
    }
  }

  // 以上所有中低层错误都没有处理，而是直接选择上抛，最后交给顶层统一处理
  ```

## 创建 log 日志

- 创建日期文件，并写入错误信息

  - 1.创建时间的时区问题(toISOString)，可以自己改也可以 toLocaleString

  ```js
  const fs = require("fs");
  const path = require("path");

  /**
   * 日志文件：
   *  1.记录日期快捷方法 new Date.toLocaleString(): 用于将日期时间转换为 “本地化字符串”，格式会根据运行环境的语言和地区设置自动调整
   *  2.日期格式 toISOString的返回的是UTC 时区的标准时间字符串， 中国是UTC+8
   * （格式：YYYY-MM-DDTHH:mm:ss.sssZ），例如 2024-10-17T07:35:20.123Z（Z 表示 UTC 时区）， 时区不同会造成，北京时间同一天的不同时间在utc时区被划分为2天
   *  解决方法是，手写一个new Date获取北京时间， 或者调用toLocaleString的api
   *
   * 3.path.join / path.resolve 前者可以处理相对路径，后者不行
   */

  // --------------------------
  // 1. 模拟数据源（包含正常数据和错误数据）
  // --------------------------
  const userDataList = [
    { id: "u001", name: "张三", level: 1 }, // 正常：普通用户
    { id: "u002", name: "李四", level: 2 }, // 正常：会员
    { name: "王五", level: 3 }, // 错误：缺少id
    { id: "u004", name: "赵六", level: "admin" }, // 错误：level类型错误（应为数字）
    { id: "u005", name: "钱七" }, // 错误：缺少level字段
    { id: "u006", name: "孙八", level: 3 }, // 正常：管理员
  ];

  // --------------------------
  // 2. 日志记录工具函数
  // --------------------------
  /**
   * 记录错误日志
   * @param {string} errorMsg 错误信息
   * @param {string|number} dataId 错误数据的id（无id则用索引）
   */
  function logError(errorMsg, dataId) {
    const logDir = path.join(__dirname, "error-logs");
    // 确保日志目录存在
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    // 日志内容（包含时间、数据标识、错误信息）
    const logContent = `[${new Date().toLocaleString()}] 数据ID: ${dataId} 错误: ${errorMsg}\n`;
    // 追加到日志文件（每天一个日志文件）格式: 年月日T时分秒
    const logFileName = `error-${new Date().toISOString().split("T")[0]}.txt`;
    const logPath = path.join(logDir, logFileName);
    fs.appendFileSync(logPath, logContent, "utf8");
    console.log(`❌ 已记录错误日志（数据ID: ${dataId}）`);
  }

  // --------------------------
  // 3. 数据处理函数（可能报错）
  // --------------------------
  /**
   * 对单条用户数据进行分类
   * @param {Object} user 单条用户数据
   * @returns {Object} 分类结果
   * @throws {Error} 数据格式错误时抛出异常
   */
  function classifyUser(user) {
    // 校验数据格式（缺少必要字段则报错）
    if (!user.id) {
      throw new Error("缺少id字段");
    }
    if (user.level === undefined) {
      throw new Error("缺少level字段");
    }
    if (typeof user.level !== "number") {
      throw new Error(`level应为数字，实际为${typeof user.level}`);
    }

    // 正常分类逻辑
    let category;
    if (user.level === 1) {
      category = "普通用户";
    } else if (user.level === 2) {
      category = "会员用户";
    } else if (user.level === 3) {
      category = "管理员";
    } else {
      category = "未知等级";
    }

    return {
      id: user.id,
      name: user.name,
      category: category,
    };
  }

  // --------------------------
  // 4. 主流程：遍历数据，处理并捕获错误
  // --------------------------
  function processAllUsers() {
    const result = []; // 存储处理成功的结果

    userDataList.forEach((user, index) => {
      try {
        // 尝试处理当前数据
        const classified = classifyUser(user);
        result.push(classified);
        console.log(
          `✅ 处理成功：${user.id || "无ID"} - ${classified.category}`
        );
      } catch (err) {
        // 捕获错误：记录日志（用id或索引标识数据）
        const dataId = user.id || `索引${index}`; // 无id则用数组索引
        logError(err.message, dataId);
        // 不做其他处理，直接进入下一次循环（跳过当前数据）
      }
    });

    console.log("\n===== 处理完成 =====");
    console.log("成功处理的数据：", result);
    console.log("错误日志已保存到：", path.join(__dirname, "error-logs"));
  }

  // 启动处理
  processAllUsers();
  ```

- 手动处理年月日如下

  ```js
  /**
   * 手动处理年月日
   * @returns String 文件名 年月日格式
   */
  function DateFormat() {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(0, 2);
    const day = String(date.getMonth()).padStart(0, 2);
    return `${year}-${month}-${day}`;
  }

  const today = DateFormat();
  console.log(today);
  ```

## 重复数据合并

- 利用 find 和 reduce 进行数据合并

  ```js
  // 筛选问题
  const orderList = [
    {
      orderId: "OD20240501001",
      goods: ["衬衫", "裤子"],
      status: "待付款",
    },
    {
      orderId: "OD20240501002",
      goods: ["运动鞋"],
      status: "已发货",
    },
    {
      orderId: "OD20240501001", // 重复orderId
      goods: ["袜子"], // 新增商品
      status: "已付款", // 状态更新
    },
    {
      orderId: "OD20240501003",
      goods: ["背包"],
      status: "待发货",
    },
  ];

  // acc是已经存入数据的临时表
  const finalOrderList = orderList.reduce((acc, item) => {
    // 如果重复会返回acc的重复item
    const existInfo = acc.find((info) => info.orderId === item.orderId);
    if (existInfo) {
      // 完善重复数据的信息
      existInfo.goods = [...existInfo.goods, ...item.goods];
      existInfo.status = item.status;
    } else {
      acc.push(item);
    }
    return acc;
  }, []); // 初始值为空

  console.log(finalOrderList);
  ```

## 大数据优化查询（可拓）

- ==大体量数据查询==:
  - ==$expr内部的操作运算符: 形如$size 这种需要计算的==，如果针对大体量数据查询，会在每个符合条件的数据中进行运算，比如下面的数据$messages 是一个数组，那么在进行查询比较时，会对每条数据的 messages 数组长度进行获取，然后进行比对，==这是很耗时的==
  ```js
    "query": {
      "createdAt": {
          "$gte": "2025-01-01T16:00:00.000Z",
          "$lte": "2025-10-20T16:00:00.000Z"
      },
      "$expr": {
          "$gt": [
              {
                  "$size": "$messages"
              },
              1
          ]
      }
    }
  ```
  - 补充情景： 聚合函数中使用`$`unwind 拆分数组的操作，20 万条数据
    - 耗时的核心不是 $unwind 本身，而是以下两个关键问题：
      - 数据膨胀效应：如果每条文档的数组字段有 N 个元素，$unwind 后会生成「20 万 × N」条文档（比如 N=10，就变成 200 万条），后续聚合阶段（$group $sort）需要处理的数据量暴增；
      - 缺少索引支持：如果 $match 阶段没有筛选条件（或筛选条件无索引），会对全集合拆分数组，相当于 “遍历 20 万条文档 + 拆分 200 万条数据”
- ==总结核心：**重要的：合理的索引 + $match 操作缩小要拆分的范围， 这里共性是 mongodb 无法对整体数组进行操作，所以 size 是获取了数组的长度，这个需要对每条数据进行操作，而拆分 unwind 则是为了计算数组内某些数据进行必要的操作，而拆分就会导致数据变多，所以也会耗时**==

- 大数据（500 万）的查询缓慢问题

  - 1.regex 匹配正则表达式，模糊匹配，忽略大小写，可能会导致索引失效 -> 全表, 原始的 title（有大小写的情况下）， 会按照正常 unicode 方式排序
    xxxx

  ```js
  db.Topappdata.createIndex(
    { title: 1 },
    { collation: { locale: "en", strength: 2 } }
  );
  ```

  - 2.$group 直接开始分组，没任何的匹配，所以默认全部查，挨个进行分组 -> 全表 -> 没有全表查询， u 已经配置了 match
  - 可能，i/o 磁盘速度远慢于内存操作

## 合适复合索引
- ==在对查到的数据进行排序操作时，单独的索引无法解决排序高耗时的问题==，如下
  ```js
    db.topappdatas.aggregate([
      { $match: { collection_name: "TOP_GROSSING_IOS" } },
      { $sort: { time: -1, sort: 1 } },
      { $skip: 0 },
      { $limit: 20 }
    ]).explain("executionStats") // 给出查询的详细参数
  ```
- 只有collecton_name有索引是不够的，因为排序没有索引，会把查到合适的collection_name数据全部在内存中重新排序（实际163万条），这个十分的耗时，在创建相关索引collction_name(1) + time(-1) + sort(1)索引后，执行一次让数据库创建好对应的索引结构（大小高达61mb）创建好索引后，无需排序，直接就可截取前20条数据，最终速度提升很大很大
  > 注意： 复合索引优先覆盖最常用的搜索组合，过多的索引不利于数据库维护（空间大，插入数据慢等）
## 分片执行
- ==把数组按照一定数量分片，返回分片后的数组==
  ```js
  function arrayChunks(arr, size) {
    let chunks = [];
    for (let i = 0; i < arr.length; i += size) {
      let chunk = arr.slice(i, i + size);
      chunks.push(chunk);
    }
    return chunks;
  }
  ```
- 数据格式大致为 (10 为一组)
  ```
    chunks = [
      [item1, item2, ..... , item10],
      [item11, item12, ..... , item20],
      [item21, item22, ..... , item30],
      ......
    ]
  ```
  > 通过 chunks[x]获取每一组的数据

## nodemon-ignore

- 有时用 nodemon 执行运行文件时，它会默认扫描项目文件是否变化，当项目文件变化的时候会重新执行，这是它的特性，但是如果代码中涉及文件创建和删除等操作时也会被误认为项目文件发生变化，从而重复执行陷入循环
- ==解决： 项目根目录下配置 nodemon.json 文件，在内部配置忽略的文件地址 ignore==
  ```json
  {
    "ignore": ["testData/addphotosByChunk/**/*"]
  }
  ```

## 重定向下载图片
- 代码可用，给一个网络图片的链接，即可下载到本地
  ```js
    /**
    * 递归处理重定向的图片下载函数（优化错误返回）
    * @param {string} imageUrl - 图片URL
    * @param {string} saveDir - 保存目录
    * @param {string} fileName - 保存文件名
    * @param {number} redirectCount - 已重定向次数
    */
    async function downloadImageWithRedirect(imageUrl, saveDir, fileName, redirectCount = 0) {
        try {
            if (redirectCount > 3) {
                // 失败时返回包含URL的错误信息
                return {
                    success: false,
                    message: '超过最大重定向次数，可能存在循环跳转',
                    url: imageUrl,
                    error: new Error('超过最大重定向次数')
                };
            }

            // 创建保存目录（同上）
            if (!fs.existsSync(saveDir)) {
                fs.mkdirSync(saveDir, { recursive: true });
            }

            // 处理文件名（同上）
            if (!fileName) {
                const urlParts = new URL(imageUrl).pathname.split('/');
                fileName = urlParts.pop() || `image_${Date.now()}.jpg`;
                if (!fileName.includes('.')) fileName += '.jpg';
            }

            const savePath = path.join(saveDir, fileName);

            return new Promise((resolve) => { // 注意：此处仅用resolve，错误在内部处理
                const urlObj = new URL(imageUrl);
                const requestOptions = {
                    hostname: urlObj.hostname,
                    path: urlObj.pathname + urlObj.search,
                    port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                    protocol: urlObj.protocol,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                    }
                };

                const request = https.request(requestOptions, (response) => {
                    if ([301, 302].includes(response.statusCode)) {
                        const redirectUrl = response.headers.location;
                        if (!redirectUrl) {
                            resolve({
                                success: false,
                                message: '重定向状态码存在，但未返回新地址',
                                url: imageUrl,
                                error: new Error('重定向无新地址')
                            });
                            return;
                        }
                        // 递归调用并返回结果
                        downloadImageWithRedirect(redirectUrl, saveDir, fileName, redirectCount + 1)
                            .then(resolve);
                        return;
                    }

                    if (response.statusCode !== 200) {
                        resolve({
                            success: false,
                            message: `请求失败，状态码: ${response.statusCode}`,
                            url: imageUrl,
                            error: new Error(`状态码异常: ${response.statusCode}`)
                        });
                        response.resume();
                        return;
                    }

                    const fileStream = fs.createWriteStream(savePath);
                    response.pipe(fileStream);

                    fileStream.on('finish', () => {
                        fileStream.close();
                        resolve({
                            success: true,
                            message: `图片已保存到: ${savePath}`,
                            path: savePath,
                            url: imageUrl
                        });
                    });

                    fileStream.on('error', (err) => {
                        fs.unlink(savePath, () => {});
                        resolve({
                            success: false,
                            message: `写入文件失败: ${err.message}`,
                            url: imageUrl,
                            error: err
                        });
                    });
                });

                request.on('error', (err) => {
                    resolve({
                        success: false,
                        message: `请求图片失败: ${err.message}`,
                        url: imageUrl,
                        error: err
                    });
                });

                request.setTimeout(10000, () => {
                    request.abort();
                    resolve({
                        success: false,
                        message: '请求超时（超过10秒）',
                        url: imageUrl,
                        error: new Error('请求超时')
                    });
                });

                request.end();
            });
        } catch (err) {
            // 捕获其他可能的同步错误（如URL解析失败）
            return {
                success: false,
                message: `下载过程出错: ${err.message}`,
                url: imageUrl,
                error: err
            };
        }
    }
  ```


## fs文件整理
- 提取部分fs操作文件的逻辑
- (renameSync修改文件路径和修改名字)
  - 提升目录(Phototag,Node/fs笔记中有改名或改路径的用法)
  - 文件改名(附加nanoid)
    ```js
      // 在字符集appphabet中随机生成长度为10的随机字符，nanoid包比uuid小
      const { customAlphabet } = await import("nanoid");
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      const name = customAlphabet(alphabet, 10)();
    ```
  - 文件分割
- 一级/二级目录读取， 判断目录isDirectory, 是目录继续读取
- 移动文件（提升目录）/重命名文件 renameSync
- 根据后缀删除文件
  - 首先读区文件readdirSync，对读取的对象file获取后缀（.extname(file)）, 没有用withFileTypes
## row与fixed
- 如果flex+允许换行，页面变窄会动态加高
- position:fixed脱离文档流，下面的文档会上移，需要确定fixed元素的高度，下面的元素margin-top提前给出位置
  > 2者结合可能会在页面变窄，内容加高时会遮挡，最好设计为flex+不换行+动态分配宽间距+固定的高度
  
## 练习下axios基本的用法
- 基本三个参数， `axios.method(url, data, params)`
  - method: 请求方式 get/post/put(更新)/delete
  - url: 请求地址
  - data: 请求体，比如query/formData/body，后端用req接受， 同时get请求的参数要放入params，data不接受get请求的参数
  - params： 请求配置，就比如设置请求头，`headers: {Content-Type: 'multipart/form-data'}` 

  
## 顶部固定sticky
- sticky 生效条件：必须设置 top/bottom/left/right 其中一个阈值（这里用 top: 0px）可以有负数, ==这里的top等相对的是父元素,要想固定在最顶部就要相对于body等根元素才行==
- 父元素不能有 overflow: hidden（本示例中 body 和父容器均无此限制）
  > ==stuAndtest内的sticky.html已经测试，效果很好==

## 前端存储与过期
- 注意： ==前端是展示的，存储的数据是不安全的，所以涉及重要数据的存储和过期管理还是要后端来做==
  ```js
    // 前端存储的数据无论是临时(session)的还是永久的(local)，都是可以设计过期时间的
    // 但是前端保存的数据应当是无关紧要的数据，同时随着用随删除，比如 如果前端保存了token，保质期为7天，这是不行的，因为前端（客户端）所有的都是可以改的，应当是后端使用jwt加密和保质期，后端解析才行

    /**
    * 设置带过期时间的本地存储
    * @param {*} key 存储键名
    * @param {*} value 存储值（任意类型，支持json序列化）
    * @param {*} expireSeconds 过期时间（秒） 0表示永不过期
    * @param {*} type 存储类型 local / session
    */
    export function setExpireStorage(
      key,
      value,
      expireSeconds = 0,
      type = "local"
    ) {
      const storage = type === "local" ? localStorage : sessionStorage;
      const data = {
        value, // 值
        expireSeconds: expireSeconds > 0 ? new Date() + expireSeconds * 1000 : 0, // 过期时间，单位秒，0即永久
      };
      // 根据键值对在本地进行存储，记得JSON序列化data数据
      storage.setItem(key, JSON.stringify(data));
    }

    /**
    * 读取带过期时间的本地存储
    * @param {*} key 键
    * @param {*} type 存储类型
    */
    export function getExpireStorage(key, type = "local") {
      const storage = type === "local" ? localStorage : sessionStorage;
      const storedStr = storage.getItem(key);

      try {
        // 1.无存储数据
        if (!storedStr) return null;
        // 解析JSON数据
        const storedData = JSON.parse(storedStr);
        const { value, expireTime } = storedData;
        // 校验过期行为
        if (expireTime === 0 || Date.now() < expireTime) {
          return value;
        } else {
          storage.removeItem(key); // 过期即删除
          return null;
        }
      } catch (error) {
        // 数据异常，删除数据
        storage.removeItem(key);
        console.error("读取数据失败", error);
        return null;
      }
    }
  ```
  > 主要代码在stuAndtest也有`07前端存储工具.js`

## 动态路由筛选
- 根据用户权限动态筛选路由时，一个要确定el-menu的显示，一个确定路由的注册
- 其中el-menu的显示是后端可以根据组件要求，在后端设置好数值返回给前端进行注册，但是注册路由不可以从用相同方式从后端返回，因为后端返回注册信息只能是字符串，而字符串是不能进行路由注册的
  ```json
    // 数据库中返回给前端的数据
    // components字段是字符串，不能直接进行路由注册
    {
      "name": "/Content",
      "path": "api/test/content",
      "components": "() => import "@/views/components/content.vue"
    }
  ```
  > ==在08和09中，给出了筛选引入路由的方式，提前在筛选函数中选择好需要引入的路由，然后在路由注册时，只注册筛选后的路由==，两者之间的联系字段根据实际情况选择，代码中的链接字段是name

## 全路由筛选
- 和动态路由筛选不同的是，全路由筛选是根据用户权限，动态筛选出需要显示的路由，==路由在一开始已经全部注册，包括el-menu也是全部显示，只是在路由守卫中进行拦截，如果用户没有权限，就导引到noauth页面==，而动态路由筛选是根据用户权限，动态筛选出需要注册的路由，如果进入没有注册的路由会白屏，相对来说全路由筛选对用户更加友好，会提示用户没有权限而不是直接白屏

- ==在路由注册和el-menu中，把所有路由统统处理，分为无需鉴权的页面（不用登录）， 需要登录访问的页面以及管理员登录访问的页面==
- 注册路由的配置 （router/index.js）
  ```js
    // 例如 meta.requiresAuth 来判断是否需要认证
    // 通过 meta.requiresAdmin 来判断是否需要管理员权限
    {
      path: '/',
      name: 'Login',
      component: () => import('../views/Login.vue'),
      meta: {
        requiresAuth: false, // 登录页不需要认证
      },
    }

    // 登录后才能访问的页面
    {
      path: 'cronjob',
      component: () => import('../views/CronJob.vue'),
    },

    {
      path: 'users',
      component: () => import('../views/Users.vue'),
      meta: {
        requiresAdmin: true, // 需要管理员权限
      },
    },

  ```
  > 记得el-menu路由也要配置好，没有权限之分，全部显示，遇到没有权限的用户，显示noauth页面即可，不会白屏，界面友好
- ==路由守卫（重点,包含刷新页面重置身份）==
  ```js
    router.beforeEach(async (to, from, next) => {
      // 获取路由元信息，子路由会继承父路由的元信息
      const requiresAuth =
        to.meta.requiresAuth !== undefined ? to.meta.requiresAuth : true // 默认需要认证
      const requiresAdmin = to.meta.requiresAdmin || false

      // 获取当前用户状态
      const token = localStorage.getItem('tsadminToken')
      const phoneToken = localStorage.getItem('tsadminPhoneToken')
      let userRole = store.state.role.role // vuex存储用户角色
      let isAdmin = userRole === 'admin'

      /** 一步步列出情况，记得return终端处理和next()放行 */
      // 不需要登录的页面直接放行
      if (!requiresAuth) {
        next()
        return
      }

      // 需要登录但未登录的情况
      if (!token || !phoneToken) {
        next('/content/noauth')
        return
      }

      // 关键修改：如果角色信息为空且存在token，等待角色信息恢复
      // 这个情况属于用户登录但是刷新页面刷新了vuex，所以要重新请求角色信息
      // 等待角色信息恢复后判断是否是管理员才会放行
      // 正确顺序 “重新获取用户身份 -> 根据身份显示页面” 
      if (!userRole && token && phoneToken) {
        try {
          // 直接调用 action 获取用户角色
          await store.dispatch('role/' + modalActionTypes.fetchUserInfoAndMenu)
          userRole = store.state.role.role
          isAdmin = userRole === 'admin'
          console.log('角色信息已在路由守卫中恢复：', userRole)
        } catch (error) {
          console.error('恢复角色信息失败：', error)
        }
      }

      // console.log(`您的身份是${userRole}`)

      // 需要管理员权限的页面
      if (requiresAdmin && !isAdmin) {
        next('/content/noauth')
        return
      }

      // 所有验证通过
      next()
    })
  ```
  > noauth页面是没有权限访问的简单vue页面（记得注册这个页面时赋予meta.requiresAuth: false），会提示用户没有权限访问，而不是直接白屏
## 上传图片文件
- 文件（图片）的基本操作
  ```html
    <input
      class="addImage"
      type="file"
      accept="*/image"
      placeholder="选择图片"
      multiple
    />
  ``` 
  ```js
    const addImageBtn = document.querySelector(".addImage");

    function imageToBase64(file) {
      console.log("图片转化base64", file);
      // 创建浏览器文件阅读器 （异步，通过onload/onerror来确定读取结果)
      const reader = new FileReader();
      // 对file文件进行阅读，并转化为base64格式
      reader.readAsDataURL(file);
      /**
       *  readAsDataURL(file) 读取文件并转化为base64  适用图片/小文件
       *  readAsText(file) 读取文件转化文本字符串 适用txt文本文件
       *  readAsArrayBuffer(file) 读取文件转化buffer 适用大文件，视频与音频等
       */

      reader.onload = (e) => {
        const base64Image = e.target.result;
        console.log("图片转化成功", base64Image);
      };

      reader.onerror = (err) => {
        console.log("图片转化失败", err);
      };
    }

    addImageBtn.addEventListener("change", (evt) => {
      console.log("上传了图片");
      // 获取文件
      const files = evt.target.files;
      console.log("files", files); // FileList类型数据
      const filesArray = Array.from(files);
      console.log("fileArray", filesArray); // 转为数组类型

      filesArray.forEach((file) => {
        // File类型，有图片文件的许多属性 name type类型 size大小等
        if (file.type.startsWith("image/")) {
          imageToBase64(file);
        }
      });
    });
  ```
  > ==1.new FileReader是浏览器内置**异步**读取文件工具，可以转化为多种类型==
  > 2.多上传文件的类型为FileList类型，可以转化为数组类型后再次使用更好
## map/filter/forEach
- ==规律总结==
  - 要「做事不产出新数组」→ forEach；
  - 要「改元素形式，产出新数组」→ map；
  - 要「留符合条件的，产出新数组」→ filter。
- 1.例如map
  ```js
    const a = [1, 2, 3, 4, 5];

    // map,对每一项数据的修改
    const mapA = a.map((item) => {
      const num = item;
      return num + 10;
    });
    console.log("mapA", mapA); // [11,12,13,14,15]
  ```
- 2.filter
  ```js
    const filterA = a.filter((item) => {
      return item > 2; // 大于2返回true，数组保留
    });
    console.log("filterA", filterA); // [3,4,5]
  ```
- 3.forEach ==return 可以跳过forEach的一次循环，不可中断==
  ```js
    // forEach执行副作用。即对数组每个元素执行特定的操作
    // 原数组b不会自动修改，也不会返回新数组，这就是利用数组内的元素进行操作而已
    const b = [1, 2, 3];
    b.forEach((item, index) => {
      if (a.includes(item)) console.log("b拥有", index + 1);
    });

    // 打印日志(信息)
    const fruits = ["苹果", "香蕉", "橙子"];
    fruits.forEach((fruit) => console.log(`水果：${fruit}`));

    // 执行副作用，比如更新数据，操作dom
    const users = [
      { name: "Alice", age: 20 },
      { name: "Bob", age: 25 },
    ];
    users.forEach((item) => {
      item.age = item.age + 1;
    });
    console.log(users);

    // 示例2：批量操作DOM（创建列表项）
    const colors = ["红", "绿", "蓝"];
    const ul = document.createElement("ul");
    colors.forEach((color) => {
      const li = document.createElement("li");
      li.textContent = color;
      ul.appendChild(li);
    });
    document.body.appendChild(ul);
  ```
| 对比维度                | forEach                          | map                              | filter                          |
|-------------------------|----------------------------------|----------------------------------|---------------------------------|
| 核心目的                | 遍历执行「副作用操作」（无返回值） | 元素「转换/映射」，生成新数组    | 元素「筛选/过滤」，生成新数组    |
| 返回值                  | undefined（无返回值）             | 新数组（与原数组长度一致）       | 新数组（长度 ≤ 原数组）         |
| 核心场景（必选此方法）  | 1. 打印/日志输出、统计外部变量<br>2. 批量操作 DOM（创建/修改元素）<br>3. 发送异步请求（如遍历数组调接口）<br>4. 手动修改对象数组的属性（非生成新数组）<br>5. 替代传统 for 循环（无复杂控制） | 1. 元素值转换（如平方、格式化）<br>2. 类型转换（如数字→字符串、对象→属性值）<br>3. 提取对象数组的指定属性（如用户列表→用户名列表）<br>4. 接口返回数据格式化（如字段重命名） | 1. 保留符合条件的元素（如筛选偶数、成年用户）<br>2. 过滤无效数据（空值、undefined、不符合规则的数据）<br>3. 搜索/筛选功能（如根据关键词过滤列表）<br>4. 去重前的条件筛选（如过滤重复项的前置判断） |
| 不适用场景              | 1. 需要返回新数组<br>2. 需中断遍历<br>3. 元素转换/筛选需求 | 1. 无需生成新数组的遍历操作<br>2. 副作用操作（如修改DOM、发请求）<br>3. 元素筛选（会保留 undefined） | 1. 无需生成新数组的遍历操作<br>2. 元素转换（如值修改、类型转换）<br>3. 副作用操作（如打印、修改外部变量） |
| 数据处理逻辑            | 只遍历，不改变原数组长度（可手动改元素属性） | 一一对应转换，不改变原数组       | 条件判断保留，不改变原数组       |
| 副作用推荐              | 推荐（核心用途就是处理副作用）    | 不推荐（应保持纯函数，仅做转换） | 不推荐（应保持纯函数，仅做筛选） |
| 遍历控制（中断/跳过）   | 无法用 return/break 中断（仅能 throw 异常，不推荐）；return 仅跳过当前循环 | 无法中断，必须遍历所有元素       | 无法中断，必须遍历所有元素       |
| 稀疏数组处理            | 遍历空槽（回调参数为 undefined）  | 空槽→undefined（保留原长度）     | 过滤空槽（不保留在新数组）       |
| 代码简洁性（对应场景）  | 高（无需处理返回值）              | 高（一行完成转换，无需手动 push） | 高（一行完成筛选，无需手动判断） |

## includes与Set.has
- ==两种常用方法，大方法更推荐set==
  ```js
    const allFruits = ["苹果", "香蕉", "橙子", "葡萄", "芒果", "榴莲"];
    const targetFruits = ["苹果", "香蕉", "橙子"]; // 目标值集合

    const result = allFruits.filter((fruit) => targetFruits.includes(fruit));
    console.log(result);

    const targetSet = new Set(targetFruits);
    const filtered2 = allFruits.filter((fruit) => targetSet.has(fruit));
    console.log(filtered2); // ['苹果', '香蕉', '橙子']（结果一致，效率更高）

    // 如若选择排除某些元素加！ 取反即可
  ```
- 筛选多个条件例如
  ```js
    const products = [
      { name: "苹果", tags: ["红色", "圆形", "水果"] },
      { name: "香蕉", tags: ["黄色", "长形", "水果"] },
      { name: "红球", tags: ["红色", "圆形", "玩具"] },
    ];
    const requiredTags = ["红色", "圆形"]; // 必须同时包含这两个标签
    const requiredSet = new Set(requiredTags);

    // every 全量遍历方法，条件false停止遍历并返回， 只返回布尔值
    const filtered = products.filter((product) =>
      requiredTags.every(
        (tag) => requiredSet.has(tag) && product.tags.includes(tag)
      )
    );
    console.log(filtered); // [{ name: '苹果', ... }, { name: '红球', ... }]
  ```
## some与every



