## new Error
- 错误会被try-catch捕获，可以通过`new Error()`创建错误实例，然后通过throw向上抛，直到遇到catch捕获，否则抛到控制台，直接报错
- ==new Error的参数是字符串格式，会对传入的数据自动执行toString，如果直接传递对象，会变成`[Object object]`==
  ```js
    // 错误地
    throw new Error({
      errMsg: "...",
      success: false
    }) // 在这一步对象已经被转化了，上抛出去的信息无效化([Object object])
  ```
- 1.可以直接给err添加新的属性保存对象信息
  ```js
    const err = new Error('数据出错')
    // 添加自定义属性
    err.errDetail = {
      errMsg: "..."
      success: false
    }
    throw err
  ```
- 2.也可以自己定一个错误类，继承Error
  ```js
    class WoozyError extends Error {
      constructor(message, option = {}){
        super(message)
        this.errName = 'WoozyError'
        this.code = option.code
        this.errDetail = option.errDetail
      }
    }

    throw new WoozyError('自定义错误', { code: -1001, errDetail: { errMsg: "...", success: false}})
  ```
- 解析错误信息,同过catch捕获后，有几个属性
  ```js
    .catch((err) => {
      console.log(err.message) // new Error传入的字符串信息，即“数据出错”
      console.log(err.stack) // 错误栈
      console.log(err.errDetail) // 自定义错误的信息（对象格式）
    })
  ```
## try-catch深层获取
- ==**先看上一章new Error**==
- 普通的错误获取：
  ```js
    // 在嵌套try-catch中，如下，三层调用关系（底层 → 中间层 → 上层），每层都可能抛出错误
    // 但是中间每一次捕获错误后，继续上抛错误都会重新new Error一个新的错误实例，而原始错误数据会丢失，所以经过层级覆盖后，底层操作的错误会被覆盖，最终追溯错误只能到上层业务的函数层级（包括调用栈）
    // 1. 底层函数（原始错误发生地）
    function底层操作() {
      throw new Error("数据库连接失败"); // 根因错误
    }

    // 2. 中间层函数（处理底层结果）
    function中间处理() {
      try {
        底层操作();
      } catch (err) {
        // 无 cause：仅抛出新错误，原始错误被丢弃
        throw new Error("数据处理失败");
      }
    }

    // 3. 上层业务函数（调用中间层）
    function上层业务() {
      try {
        中间处理();
      } catch (err) {
        // 无 cause：再次抛出新错误，中间层错误被丢弃
        throw new Error("业务执行失败");
      }
    }

    // 最终调用
    try {
      上层业务();
    } catch (err) {
      console.log(err.message); // 只能看到 "业务执行失败"
      console.log(err.stack);   // 堆栈仅显示上层业务的错误位置
      // 完全无法知道底层的 "数据库连接失败" 根因
    }
  ```
- 2.深层错误处理(==中间人cause==)
  ```js
    // 第一步：正确抛出错误（给Error实例加自定义属性）
    function fn() {
      const err = new Error('登录token过期'); // 第一个参数传字符串（标准用法）
      // 挂载自定义属性
      err.errorDetail = { error: 'token expired' }
      err.code = 'TOKEN_EXPIRED'; // 可选：加错误码，便于上层判断
      throw err;
    }

    // 第二步：catch中直接透传（或包装后透传）
    async function wrapFn() {
      try {
        await fn();
      } catch (error) {
        // 如需包装，可继续添加属性，或用cause传递
        const wrapErr = new Error('登录失败', { cause: error }); // 包装后透传
        throw wrapErr;
      }
    }

    // 第三步：上层捕获（正确读取属性）
    wrapFn().catch((err) => {
      console.log('错误信息：', err.message); // 登录失败（包装后的message）
      console.log('原始错误：', err.cause.message); // 登录token过期（原始message）
      console.log('错误详情：', err.cause.errorDetail); // token expired（自定义属性）
      console.log('错误码：', err.cause.code); // TOKEN_EXPIRED（自定义错误码）
      
      // 如需打印完整信息，用JSON.stringify（处理cause）
      console.log('完整错误：', JSON.stringify({
        message: err.message,
        cause: {
          message: err.cause.message,
          errorDetail: err.cause.errorDetail,
          code: err.cause.code
        }
      }, null, 2));
    });
  ```
- ==cause 本质就是 错误传递的 “中间人”/“载体”，作用是把底层错误的完整信息（包括原始错误对象、错误栈）“附着” 在新的 Error 实例上，向上传递==
  - 底层 fn() 抛出原始错误 error（可能是普通 Error 或自定义错误）；
  - 中间层 wrapFn() 的 catch 捕获到 error，用 new Error('登录失败', { cause: error }) 包装 ——> 新 Error 的 cause 属性会保存原始错误 error；
  - 上层捕获到包装后的错误 err，通过 err.cause 就能拿到底层的原始错误，进而读取原始的 message、自定义属性等。
  > 简单说：cause 就是为了避免底层错误信息丢失，专门用来 “嵌套传递” 原始错误的机制（ES2022 标准特性）。
  > ==注意：不要向cause传递非Error实例的值，比如对象，字符串等，否则实效==
- ==其中错误栈stack会自动追加到顶层错误的后面==
  ```js
    .catch((err) => {
      console.log(err.stack) // 所有的错误栈，从顶层到报错的位置
      if(err.cause){ // 优先确保底层是否报错，如果只有顶层报错，是不会包装cause的，即undefined
        console.log(err.cause.stack) // 仅打印底层报错的错误栈
      }
    })
  ```
- ==全部报错stack打印: 原始错误的栈会以 Cause: 或 Caused by: 开头拼接在后面，完整保留调用链路。==
  ```
    ===== 包装后的错误栈 =====
    Error: 登录失败（中间层包装）
        at wrapFn (/xxx/test.js:15:11) // 中间层包装错误的位置
        at ...（省略其他调用链路）
    Caused by: Error: 登录token过期 // 原始错误的栈（自动关联）
        at fn (/xxx/test.js:4:21) // 原始错误发生的位置
        at ...（省略其他调用链路）
  ```

## 创建 log 日志

- 创建日期文件，并写入错误信息

  - 1.创建时间的时区问题(toISOString)，可以自己改也可以 toLocaleString

  ```js
  const fs = require("fs");
  const path = require("path");

  /**
   * 日志文件：
   *  1.记录日期快捷方法 new Date.toLocaleString(): 用于将日期时间转换为 “本地化字符串”，格式会根据运行环境的语言和地区设置自动调整
   *  2.日期格式 toISOString的返回的是UTC 时区的标准时间字符串， 中国是UTC+8
   * （格式：YYYY-MM-DDTHH:mm:ss.sssZ），例如 2024-10-17T07:35:20.123Z（Z 表示 UTC 时区）， 时区不同会造成，北京时间同一天的不同时间在utc时区被划分为2天
   *  解决方法是，手写一个new Date获取北京时间， 或者调用toLocaleString的api
   *
   * 3.path.join / path.resolve 前者可以处理相对路径，后者不行
   */

  // --------------------------
  // 1. 模拟数据源（包含正常数据和错误数据）
  // --------------------------
  const userDataList = [
    { id: "u001", name: "张三", level: 1 }, // 正常：普通用户
    { id: "u002", name: "李四", level: 2 }, // 正常：会员
    { name: "王五", level: 3 }, // 错误：缺少id
    { id: "u004", name: "赵六", level: "admin" }, // 错误：level类型错误（应为数字）
    { id: "u005", name: "钱七" }, // 错误：缺少level字段
    { id: "u006", name: "孙八", level: 3 }, // 正常：管理员
  ];

  // --------------------------
  // 2. 日志记录工具函数
  // --------------------------
  /**
   * 记录错误日志
   * @param {string} errorMsg 错误信息
   * @param {string|number} dataId 错误数据的id（无id则用索引）
   */
  function logError(errorMsg, dataId) {
    const logDir = path.join(__dirname, "error-logs");
    // 确保日志目录存在
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    // 日志内容（包含时间、数据标识、错误信息）
    const logContent = `[${new Date().toLocaleString()}] 数据ID: ${dataId} 错误: ${errorMsg}\n`;
    // 追加到日志文件（每天一个日志文件）格式: 年月日T时分秒
    const logFileName = `error-${new Date().toISOString().split("T")[0]}.txt`;
    const logPath = path.join(logDir, logFileName);
    fs.appendFileSync(logPath, logContent, "utf8");
    console.log(`❌ 已记录错误日志（数据ID: ${dataId}）`);
  }

  // --------------------------
  // 3. 数据处理函数（可能报错）
  // --------------------------
  /**
   * 对单条用户数据进行分类
   * @param {Object} user 单条用户数据
   * @returns {Object} 分类结果
   * @throws {Error} 数据格式错误时抛出异常
   */
  function classifyUser(user) {
    // 校验数据格式（缺少必要字段则报错）
    if (!user.id) {
      throw new Error("缺少id字段");
    }
    if (user.level === undefined) {
      throw new Error("缺少level字段");
    }
    if (typeof user.level !== "number") {
      throw new Error(`level应为数字，实际为${typeof user.level}`);
    }

    // 正常分类逻辑
    let category;
    if (user.level === 1) {
      category = "普通用户";
    } else if (user.level === 2) {
      category = "会员用户";
    } else if (user.level === 3) {
      category = "管理员";
    } else {
      category = "未知等级";
    }

    return {
      id: user.id,
      name: user.name,
      category: category,
    };
  }

  // --------------------------
  // 4. 主流程：遍历数据，处理并捕获错误
  // --------------------------
  function processAllUsers() {
    const result = []; // 存储处理成功的结果

    userDataList.forEach((user, index) => {
      try {
        // 尝试处理当前数据
        const classified = classifyUser(user);
        result.push(classified);
        console.log(
          `✅ 处理成功：${user.id || "无ID"} - ${classified.category}`
        );
      } catch (err) {
        // 捕获错误：记录日志（用id或索引标识数据）
        const dataId = user.id || `索引${index}`; // 无id则用数组索引
        logError(err.message, dataId);
        // 不做其他处理，直接进入下一次循环（跳过当前数据）
      }
    });

    console.log("\n===== 处理完成 =====");
    console.log("成功处理的数据：", result);
    console.log("错误日志已保存到：", path.join(__dirname, "error-logs"));
  }

  // 启动处理
  processAllUsers();
  ```

- 手动处理年月日如下

  ```js
  /**
   * 手动处理年月日
   * @returns String 文件名 年月日格式
   */
  function DateFormat() {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(0, 2);
    const day = String(date.getMonth()).padStart(0, 2);
    return `${year}-${month}-${day}`;
  }

  const today = DateFormat();
  console.log(today);
  ```

## 重复数据合并

- 利用 find 和 reduce 进行数据合并

  ```js
  // 筛选问题
  const orderList = [
    {
      orderId: "OD20240501001",
      goods: ["衬衫", "裤子"],
      status: "待付款",
    },
    {
      orderId: "OD20240501002",
      goods: ["运动鞋"],
      status: "已发货",
    },
    {
      orderId: "OD20240501001", // 重复orderId
      goods: ["袜子"], // 新增商品
      status: "已付款", // 状态更新
    },
    {
      orderId: "OD20240501003",
      goods: ["背包"],
      status: "待发货",
    },
  ];

  // acc是已经存入数据的临时表
  const finalOrderList = orderList.reduce((acc, item) => {
    // 如果重复会返回acc的重复item
    const existInfo = acc.find((info) => info.orderId === item.orderId);
    if (existInfo) {
      // 完善重复数据的信息
      existInfo.goods = [...existInfo.goods, ...item.goods];
      existInfo.status = item.status;
    } else {
      acc.push(item);
    }
    return acc;
  }, []); // 初始值为空

  console.log(finalOrderList);
  ```

## 大数据优化查询（可拓）

- ==大体量数据查询==:
  - ==$expr内部的操作运算符: 形如$size 这种需要计算的==，如果针对大体量数据查询，会在每个符合条件的数据中进行运算，比如下面的数据$messages 是一个数组，那么在进行查询比较时，会对每条数据的 messages 数组长度进行获取，然后进行比对，==这是很耗时的==
  ```js
    "query": {
      "createdAt": {
          "$gte": "2025-01-01T16:00:00.000Z",
          "$lte": "2025-10-20T16:00:00.000Z"
      },
      "$expr": {
          "$gt": [
              {
                  "$size": "$messages"
              },
              1
          ]
      }
    }
  ```
  - 补充情景： 聚合函数中使用`$`unwind 拆分数组的操作，20 万条数据
    - 耗时的核心不是 $unwind 本身，而是以下两个关键问题：
      - 数据膨胀效应：如果每条文档的数组字段有 N 个元素，$unwind 后会生成「20 万 × N」条文档（比如 N=10，就变成 200 万条），后续聚合阶段（$group $sort）需要处理的数据量暴增；
      - 缺少索引支持：如果 $match 阶段没有筛选条件（或筛选条件无索引），会对全集合拆分数组，相当于 “遍历 20 万条文档 + 拆分 200 万条数据”
- ==总结核心：**重要的：合理的索引 + $match 操作缩小要拆分的范围， 这里共性是 mongodb 无法对整体数组进行操作，所以 size 是获取了数组的长度，这个需要对每条数据进行操作，而拆分 unwind 则是为了计算数组内某些数据进行必要的操作，而拆分就会导致数据变多，所以也会耗时**==

- 大数据（500 万）的查询缓慢问题

  - 1.regex 匹配正则表达式，模糊匹配，忽略大小写，可能会导致索引失效 -> 全表, 原始的 title（有大小写的情况下）， 会按照正常 unicode 方式排序
    xxxx

  ```js
  db.Topappdata.createIndex(
    { title: 1 },
    { collation: { locale: "en", strength: 2 } }
  );
  ```

  - 2.$group 直接开始分组，没任何的匹配，所以默认全部查，挨个进行分组 -> 全表 -> 没有全表查询， u 已经配置了 match
  - 可能，i/o 磁盘速度远慢于内存操作

## 合适复合索引
- ==在对查到的数据进行排序操作时，单独的索引无法解决排序高耗时的问题==，如下
  ```js
    db.topappdatas.aggregate([
      { $match: { collection_name: "TOP_GROSSING_IOS" } },
      { $sort: { time: -1, sort: 1 } },
      { $skip: 0 },
      { $limit: 20 }
    ]).explain("executionStats") // 给出查询的详细参数
  ```
- 只有collecton_name有索引是不够的，因为排序没有索引，会把查到合适的collection_name数据全部在内存中重新排序（实际163万条），这个十分的耗时，在创建相关索引collction_name(1) + time(-1) + sort(1)索引后，执行一次让数据库创建好对应的索引结构（大小高达61mb）创建好索引后，无需排序，直接就可截取前20条数据，最终速度提升很大很大
  > 注意： 复合索引优先覆盖最常用的搜索组合，过多的索引不利于数据库维护（空间大，插入数据慢等）
## 分片执行
- ==把数组按照一定数量分片，返回分片后的数组==
  ```js
  function arrayChunks(arr, size) {
    let chunks = [];
    for (let i = 0; i < arr.length; i += size) {
      let chunk = arr.slice(i, i + size);
      chunks.push(chunk);
    }
    return chunks;
  }
  ```
- 数据格式大致为 (10 为一组)
  ```
    chunks = [
      [item1, item2, ..... , item10],
      [item11, item12, ..... , item20],
      [item21, item22, ..... , item30],
      ......
    ]
  ```
  > 通过 chunks[x]获取每一组的数据

## nodemon-ignore

- 有时用 nodemon 执行运行文件时，它会默认扫描项目文件是否变化，当项目文件变化的时候会重新执行，这是它的特性，但是如果代码中涉及文件创建和删除等操作时也会被误认为项目文件发生变化，从而重复执行陷入循环
- ==解决： 项目根目录下配置 nodemon.json 文件，在内部配置忽略的文件地址 ignore==
  ```json
  {
    "ignore": ["testData/addphotosByChunk/**/*"]
  }
  ```

## 重定向下载图片
- 代码可用，给一个网络图片的链接，即可下载到本地
  ```js
    /**
    * 递归处理重定向的图片下载函数（优化错误返回）
    * @param {string} imageUrl - 图片URL
    * @param {string} saveDir - 保存目录
    * @param {string} fileName - 保存文件名
    * @param {number} redirectCount - 已重定向次数
    */
    async function downloadImageWithRedirect(imageUrl, saveDir, fileName, redirectCount = 0) {
        try {
            if (redirectCount > 3) {
                // 失败时返回包含URL的错误信息
                return {
                    success: false,
                    message: '超过最大重定向次数，可能存在循环跳转',
                    url: imageUrl,
                    error: new Error('超过最大重定向次数')
                };
            }

            // 创建保存目录（同上）
            if (!fs.existsSync(saveDir)) {
                fs.mkdirSync(saveDir, { recursive: true });
            }

            // 处理文件名（同上）
            if (!fileName) {
                const urlParts = new URL(imageUrl).pathname.split('/');
                fileName = urlParts.pop() || `image_${Date.now()}.jpg`;
                if (!fileName.includes('.')) fileName += '.jpg';
            }

            const savePath = path.join(saveDir, fileName);

            return new Promise((resolve) => { // 注意：此处仅用resolve，错误在内部处理
                const urlObj = new URL(imageUrl);
                const requestOptions = {
                    hostname: urlObj.hostname,
                    path: urlObj.pathname + urlObj.search,
                    port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
                    protocol: urlObj.protocol,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                    }
                };

                const request = https.request(requestOptions, (response) => {
                    if ([301, 302].includes(response.statusCode)) {
                        const redirectUrl = response.headers.location;
                        if (!redirectUrl) {
                            resolve({
                                success: false,
                                message: '重定向状态码存在，但未返回新地址',
                                url: imageUrl,
                                error: new Error('重定向无新地址')
                            });
                            return;
                        }
                        // 递归调用并返回结果
                        downloadImageWithRedirect(redirectUrl, saveDir, fileName, redirectCount + 1)
                            .then(resolve);
                        return;
                    }

                    if (response.statusCode !== 200) {
                        resolve({
                            success: false,
                            message: `请求失败，状态码: ${response.statusCode}`,
                            url: imageUrl,
                            error: new Error(`状态码异常: ${response.statusCode}`)
                        });
                        response.resume();
                        return;
                    }

                    const fileStream = fs.createWriteStream(savePath);
                    response.pipe(fileStream);

                    fileStream.on('finish', () => {
                        fileStream.close();
                        resolve({
                            success: true,
                            message: `图片已保存到: ${savePath}`,
                            path: savePath,
                            url: imageUrl
                        });
                    });

                    fileStream.on('error', (err) => {
                        fs.unlink(savePath, () => {});
                        resolve({
                            success: false,
                            message: `写入文件失败: ${err.message}`,
                            url: imageUrl,
                            error: err
                        });
                    });
                });

                request.on('error', (err) => {
                    resolve({
                        success: false,
                        message: `请求图片失败: ${err.message}`,
                        url: imageUrl,
                        error: err
                    });
                });

                request.setTimeout(10000, () => {
                    request.abort();
                    resolve({
                        success: false,
                        message: '请求超时（超过10秒）',
                        url: imageUrl,
                        error: new Error('请求超时')
                    });
                });

                request.end();
            });
        } catch (err) {
            // 捕获其他可能的同步错误（如URL解析失败）
            return {
                success: false,
                message: `下载过程出错: ${err.message}`,
                url: imageUrl,
                error: err
            };
        }
    }
  ```


## fs文件整理
- 提取部分fs操作文件的逻辑
- (renameSync修改文件路径和修改名字)
  - 提升目录(Phototag,Node/fs笔记中有改名或改路径的用法)
  - 文件改名(附加nanoid)
    ```js
      // 在字符集appphabet中随机生成长度为10的随机字符，nanoid包比uuid小
      const { customAlphabet } = await import("nanoid");
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      const name = customAlphabet(alphabet, 10)();
    ```
  - 文件分割
- 一级/二级目录读取， 判断目录isDirectory, 是目录继续读取
- 移动文件（提升目录）/重命名文件 renameSync
- 根据后缀删除文件
  - 首先读区文件readdirSync，对读取的对象file获取后缀（.extname(file)）, 没有用withFileTypes
## row与fixed
- 如果flex+允许换行，页面变窄会动态加高
- position:fixed脱离文档流，下面的文档会上移，需要确定fixed元素的高度，下面的元素margin-top提前给出位置
  > 2者结合可能会在页面变窄，内容加高时会遮挡，最好设计为flex+不换行+动态分配宽间距+固定的高度
  
## 练习下axios基本的用法
- 基本三个参数， `axios.method(url, data, params)`
  - method: 请求方式 get/post/put(更新)/delete
  - url: 请求地址
  - data: 请求体，比如query/formData/body，后端用req接受， 同时get请求的参数要放入params，data不接受get请求的参数
  - params： 请求配置，就比如设置请求头，`headers: {Content-Type: 'multipart/form-data'}` 

  
## 顶部固定sticky
- sticky 生效条件：必须设置 top/bottom/left/right 其中一个阈值（这里用 top: 0px）可以有负数, ==这里的top等相对的是父元素,要想固定在最顶部就要相对于body等根元素才行==
- 父元素不能有 overflow: hidden（本示例中 body 和父容器均无此限制）
  > ==stuAndtest内的sticky.html已经测试，效果很好==

## 前端存储与过期
- 注意： ==前端是展示的，存储的数据是不安全的，所以涉及重要数据的存储和过期管理还是要后端来做==
  ```js
    // 前端存储的数据无论是临时(session)的还是永久的(local)，都是可以设计过期时间的
    // 但是前端保存的数据应当是无关紧要的数据，同时随着用随删除，比如 如果前端保存了token，保质期为7天，这是不行的，因为前端（客户端）所有的都是可以改的，应当是后端使用jwt加密和保质期，后端解析才行

    /**
    * 设置带过期时间的本地存储
    * @param {*} key 存储键名
    * @param {*} value 存储值（任意类型，支持json序列化）
    * @param {*} expireSeconds 过期时间（秒） 0表示永不过期
    * @param {*} type 存储类型 local / session
    */
    export function setExpireStorage(
      key,
      value,
      expireSeconds = 0,
      type = "local"
    ) {
      const storage = type === "local" ? localStorage : sessionStorage;
      const data = {
        value, // 值
        expireSeconds: expireSeconds > 0 ? new Date() + expireSeconds * 1000 : 0, // 过期时间，单位秒，0即永久
      };
      // 根据键值对在本地进行存储，记得JSON序列化data数据
      storage.setItem(key, JSON.stringify(data));
    }

    /**
    * 读取带过期时间的本地存储
    * @param {*} key 键
    * @param {*} type 存储类型
    */
    export function getExpireStorage(key, type = "local") {
      const storage = type === "local" ? localStorage : sessionStorage;
      const storedStr = storage.getItem(key);

      try {
        // 1.无存储数据
        if (!storedStr) return null;
        // 解析JSON数据
        const storedData = JSON.parse(storedStr);
        const { value, expireTime } = storedData;
        // 校验过期行为
        if (expireTime === 0 || Date.now() < expireTime) {
          return value;
        } else {
          storage.removeItem(key); // 过期即删除
          return null;
        }
      } catch (error) {
        // 数据异常，删除数据
        storage.removeItem(key);
        console.error("读取数据失败", error);
        return null;
      }
    }
  ```
  > 主要代码在stuAndtest也有`07前端存储工具.js`

## 动态路由筛选
- 根据用户权限动态筛选路由时，一个要确定el-menu的显示，一个确定路由的注册
- 其中el-menu的显示是后端可以根据组件要求，在后端设置好数值返回给前端进行注册，但是注册路由不可以从用相同方式从后端返回，因为后端返回注册信息只能是字符串，而字符串是不能进行路由注册的
  ```json
    // 数据库中返回给前端的数据
    // components字段是字符串，不能直接进行路由注册
    {
      "name": "/Content",
      "path": "api/test/content",
      "components": "() => import "@/views/components/content.vue"
    }
  ```
  > ==在08和09中，给出了筛选引入路由的方式，提前在筛选函数中选择好需要引入的路由，然后在路由注册时，只注册筛选后的路由==，两者之间的联系字段根据实际情况选择，代码中的链接字段是name

## 全路由筛选
- 和动态路由筛选不同的是，全路由筛选是根据用户权限，动态筛选出需要显示的路由，==路由在一开始已经全部注册，包括el-menu也是全部显示，只是在路由守卫中进行拦截，如果用户没有权限，就导引到noauth页面==，而动态路由筛选是根据用户权限，动态筛选出需要注册的路由，如果进入没有注册的路由会白屏，相对来说全路由筛选对用户更加友好，会提示用户没有权限而不是直接白屏

- ==在路由注册和el-menu中，把所有路由统统处理，分为无需鉴权的页面（不用登录）， 需要登录访问的页面以及管理员登录访问的页面==
- 注册路由的配置 （router/index.js）
  ```js
    // 例如 meta.requiresAuth 来判断是否需要认证
    // 通过 meta.requiresAdmin 来判断是否需要管理员权限
    {
      path: '/',
      name: 'Login',
      component: () => import('../views/Login.vue'),
      meta: {
        requiresAuth: false, // 登录页不需要认证
      },
    }

    // 登录后才能访问的页面
    {
      path: 'cronjob',
      component: () => import('../views/CronJob.vue'),
    },

    {
      path: 'users',
      component: () => import('../views/Users.vue'),
      meta: {
        requiresAdmin: true, // 需要管理员权限
      },
    },

  ```
  > 记得el-menu路由也要配置好，没有权限之分，全部显示，遇到没有权限的用户，显示noauth页面即可，不会白屏，界面友好
- ==路由守卫（重点,包含刷新页面重置身份）==
  ```js
    router.beforeEach(async (to, from, next) => {
      // 获取路由元信息，子路由会继承父路由的元信息
      const requiresAuth =
        to.meta.requiresAuth !== undefined ? to.meta.requiresAuth : true // 默认需要认证
      const requiresAdmin = to.meta.requiresAdmin || false

      // 获取当前用户状态
      const token = localStorage.getItem('tsadminToken')
      const phoneToken = localStorage.getItem('tsadminPhoneToken')
      let userRole = store.state.role.role // vuex存储用户角色
      let isAdmin = userRole === 'admin'

      /** 一步步列出情况，记得return终端处理和next()放行 */
      // 不需要登录的页面直接放行
      if (!requiresAuth) {
        next()
        return
      }

      // 需要登录但未登录的情况
      if (!token || !phoneToken) {
        next('/content/noauth')
        return
      }

      // 关键修改：如果角色信息为空且存在token，等待角色信息恢复
      // 这个情况属于用户登录但是刷新页面刷新了vuex，所以要重新请求角色信息
      // 等待角色信息恢复后判断是否是管理员才会放行
      // 正确顺序 “重新获取用户身份 -> 根据身份显示页面” 
      if (!userRole && token && phoneToken) {
        try {
          // 直接调用 action 获取用户角色
          await store.dispatch('role/' + modalActionTypes.fetchUserInfoAndMenu)
          userRole = store.state.role.role
          isAdmin = userRole === 'admin'
          console.log('角色信息已在路由守卫中恢复：', userRole)
        } catch (error) {
          console.error('恢复角色信息失败：', error)
        }
      }

      // console.log(`您的身份是${userRole}`)

      // 需要管理员权限的页面
      if (requiresAdmin && !isAdmin) {
        next('/content/noauth')
        return
      }

      // 所有验证通过
      next()
    })
  ```
  > noauth页面是没有权限访问的简单vue页面（记得注册这个页面时赋予meta.requiresAuth: false），会提示用户没有权限访问，而不是直接白屏
## 上传图片文件
- 文件（图片）的基本操作
  ```html
    <input
      class="addImage"
      type="file"
      accept="*/image"
      placeholder="选择图片"
      multiple
    />
  ``` 
  ```js
    const addImageBtn = document.querySelector(".addImage");

    function imageToBase64(file) {
      console.log("图片转化base64", file);
      // 创建浏览器文件阅读器 （异步，通过onload/onerror来确定读取结果)
      const reader = new FileReader();
      // 对file文件进行阅读，并转化为base64格式
      reader.readAsDataURL(file);
      /**
       *  readAsDataURL(file) 读取文件并转化为base64  适用图片/小文件
       *  readAsText(file) 读取文件转化文本字符串 适用txt文本文件
       *  readAsArrayBuffer(file) 读取文件转化buffer 适用大文件，视频与音频等
       */

      reader.onload = (e) => {
        const base64Image = e.target.result;
        console.log("图片转化成功", base64Image);
      };

      reader.onerror = (err) => {
        console.log("图片转化失败", err);
      };
    }

    addImageBtn.addEventListener("change", (evt) => {
      console.log("上传了图片");
      // 获取文件
      const files = evt.target.files;
      console.log("files", files); // FileList类型数据
      const filesArray = Array.from(files);
      console.log("fileArray", filesArray); // 转为数组类型

      filesArray.forEach((file) => {
        // File类型，有图片文件的许多属性 name type类型 size大小等
        if (file.type.startsWith("image/")) {
          imageToBase64(file);
        }
      });
    });
  ```
  > ==1.new FileReader是浏览器内置**异步**读取文件工具，可以转化为多种类型==
  > 2.多上传文件的类型为FileList类型，可以转化为数组类型后再次使用更好
## map/filter/forEach
- ==规律总结==
  - 要「做事不产出新数组」→ forEach；
  - 要「改元素形式，产出新数组」→ map；
  - 要「留符合条件的，产出新数组」→ filter。
- 1.例如map
  ```js
    const a = [1, 2, 3, 4, 5];

    // map,对每一项数据的修改
    const mapA = a.map((item) => {
      const num = item;
      return num + 10;
    });
    console.log("mapA", mapA); // [11,12,13,14,15]
  ```
- 2.filter
  ```js
    const filterA = a.filter((item) => {
      return item > 2; // 大于2返回true，数组保留
    });
    console.log("filterA", filterA); // [3,4,5]
  ```
- 3.forEach ==return 可以跳过forEach的一次循环，不可中断==
  ```js
    // forEach执行副作用。即对数组每个元素执行特定的操作
    // 原数组b不会自动修改，也不会返回新数组，这就是利用数组内的元素进行操作而已
    const b = [1, 2, 3];
    b.forEach((item, index) => {
      if (a.includes(item)) console.log("b拥有", index + 1);
    });

    // 打印日志(信息)
    const fruits = ["苹果", "香蕉", "橙子"];
    fruits.forEach((fruit) => console.log(`水果：${fruit}`));

    // 执行副作用，比如更新数据，操作dom
    const users = [
      { name: "Alice", age: 20 },
      { name: "Bob", age: 25 },
    ];
    users.forEach((item) => {
      item.age = item.age + 1;
    });
    console.log(users);

    // 示例2：批量操作DOM（创建列表项）
    const colors = ["红", "绿", "蓝"];
    const ul = document.createElement("ul");
    colors.forEach((color) => {
      const li = document.createElement("li");
      li.textContent = color;
      ul.appendChild(li);
    });
    document.body.appendChild(ul);
  ```
| 对比维度                | forEach                          | map                              | filter                          |
|-------------------------|----------------------------------|----------------------------------|---------------------------------|
| 核心目的                | 遍历执行「副作用操作」（无返回值） | 元素「转换/映射」，生成新数组    | 元素「筛选/过滤」，生成新数组    |
| 返回值                  | undefined（无返回值）             | 新数组（与原数组长度一致）       | 新数组（长度 ≤ 原数组）         |
| 核心场景（必选此方法）  | 1. 打印/日志输出、统计外部变量<br>2. 批量操作 DOM（创建/修改元素）<br>3. 发送异步请求（如遍历数组调接口）<br>4. 手动修改对象数组的属性（非生成新数组）<br>5. 替代传统 for 循环（无复杂控制） | 1. 元素值转换（如平方、格式化）<br>2. 类型转换（如数字→字符串、对象→属性值）<br>3. 提取对象数组的指定属性（如用户列表→用户名列表）<br>4. 接口返回数据格式化（如字段重命名） | 1. 保留符合条件的元素（如筛选偶数、成年用户）<br>2. 过滤无效数据（空值、undefined、不符合规则的数据）<br>3. 搜索/筛选功能（如根据关键词过滤列表）<br>4. 去重前的条件筛选（如过滤重复项的前置判断） |
| 不适用场景              | 1. 需要返回新数组<br>2. 需中断遍历<br>3. 元素转换/筛选需求 | 1. 无需生成新数组的遍历操作<br>2. 副作用操作（如修改DOM、发请求）<br>3. 元素筛选（会保留 undefined） | 1. 无需生成新数组的遍历操作<br>2. 元素转换（如值修改、类型转换）<br>3. 副作用操作（如打印、修改外部变量） |
| 数据处理逻辑            | 只遍历，不改变原数组长度（可手动改元素属性） | 一一对应转换，不改变原数组       | 条件判断保留，不改变原数组       |
| 副作用推荐              | 推荐（核心用途就是处理副作用）    | 不推荐（应保持纯函数，仅做转换） | 不推荐（应保持纯函数，仅做筛选） |
| 遍历控制（中断/跳过）   | 无法用 return/break 中断（仅能 throw 异常，不推荐）；return 仅跳过当前循环 | 无法中断，必须遍历所有元素       | 无法中断，必须遍历所有元素       |
| 稀疏数组处理            | 遍历空槽（回调参数为 undefined）  | 空槽→undefined（保留原长度）     | 过滤空槽（不保留在新数组）       |
| 代码简洁性（对应场景）  | 高（无需处理返回值）              | 高（一行完成转换，无需手动 push） | 高（一行完成筛选，无需手动判断） |

## includes与Set.has
- ==两种常用方法，大方法更推荐set==
  ```js
    const allFruits = ["苹果", "香蕉", "橙子", "葡萄", "芒果", "榴莲"];
    const targetFruits = ["苹果", "香蕉", "橙子"]; // 目标值集合

    const result = allFruits.filter((fruit) => targetFruits.includes(fruit));
    console.log(result);

    const targetSet = new Set(targetFruits);
    const filtered2 = allFruits.filter((fruit) => targetSet.has(fruit));
    console.log(filtered2); // ['苹果', '香蕉', '橙子']（结果一致，效率更高）

    // 如若选择排除某些元素加！ 取反即可
  ```
- 筛选多个条件例如
  ```js
    const products = [
      { name: "苹果", tags: ["红色", "圆形", "水果"] },
      { name: "香蕉", tags: ["黄色", "长形", "水果"] },
      { name: "红球", tags: ["红色", "圆形", "玩具"] },
    ];
    const requiredTags = ["红色", "圆形"]; // 必须同时包含这两个标签
    const requiredSet = new Set(requiredTags);

    // every 全量遍历方法，条件false停止遍历并返回， 只返回布尔值
    const filtered = products.filter((product) =>
      requiredTags.every(
        (tag) => requiredSet.has(tag) && product.tags.includes(tag)
      )
    );
    console.log(filtered); // [{ name: '苹果', ... }, { name: '红球', ... }]
  ```
## some与every 
- 数组的方法some/every
  ```js
    // 语法：array.some(callback(element, index, array), thisArg);
    // 回调函数：遍历数组的当前元素（必选），索引和整体的原数组 ｜ this指向

    // some特点： 回调函数返回布尔值，一旦返回true，立即停止遍历，整体返回true， 只有所有结果都为false，才返回false
    // 注意：一定要显式返回正确的布尔值，如果返回了对象，数组，字符串一律判定为false

    /** some的测试 */
    const numbers = [2, 5, 8, 12, 15];
    // 检测是否有元素 > 10
    const hasBigNumber = numbers.some((num) => num > 10);
    console.log(hasBigNumber); // true（12 满足条件，遍历到 12 后停止）

    // 而every则是全部都正确，才返回true，一旦有错误false，整体返回false，其余一样

    // some适合做存在性测试，every则是全部测试
  ```

## fetch解析和axios
- ==在用习惯axios的情况下，可能会忽略掉原生fetch等网络请求的结果是需要二次解析的==
  ```js
    // 基础的网络请求相关
    // 原生fetch请求
    const response = await fetch(`BASE_URL`, query);
    // 网络请求发起后，都会返回一个promise，异步
    if (response.ok) {
      /** 异步后成功获取的response是可独流数据，真正的数据需要json转化数据为js格式才能使用
      * 除此之外 还有
      * .text() 纯文本/HTML
      * .blob() 文件 图片等
      * .formData() 表单
      */
      const result = await response.json();
      console.log("result", result);
    }
  ```
  > ==**注意：而常用的网络请求包axios，把对应的数据结果封装进入 response.data里面，所以不需要再次解析
**==
## promise.all()
- `promises.all(proArr)`内部处理promise数组，当所有的promise都正确的返回对应结果后，按顺序把返回的结果组合成数组返回，而每次网络请求都会返回promise对象，我们需要把这些promise对象放入数组中，统一由promise.all处理它们
- ==1.错误的收集网络请求promise数组==
  ```js
    for (let i = 0; i < data.pairList.length; i++) {
      const payloadFinal = {
        ...data,
        prompt: data.pairList[i].normal, // 新增
        negativePrompt: data.pairList[i].negative,
        imageBase64: data.imageBase64Arr[i],
      };

      /**
       * 错误点： 执行return后，for循环停止，后面的循环没有意义，仅返回一个网络请求
      */

      return fetch(`${API_BASE_URL}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": "1121231d2-30d2-4bd6-a7d9-1a84df4ae2ds1b6",
        },
        body: JSON.stringify(payloadFinal),
      });
    }
  ```
- ==2.正确的方式：创建新的空数组，把对应的网络请求promise对象放入数组，然后把数组返回出去即可==
  ```js
    const requestPromises = [];

    for (let i = 0; i < data.pairList.length; i++) {
      const payloadFinal = {
        ...data,
        prompt: data.pairList[i].normal,
        negativePrompt: data.pairList[i].negative,
        imageBase64: data.imageBase64Arr[i],
      };
      console.log("i + payloadFinal", i, payloadFinal);

      // 2. 不直接 return，而是把 Promise 推入数组
      const requestPromise = fetch(`${API_BASE_URL}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": "1121231d2-30d2-4bd6-a7d9-1a84df4ae2ds1b6",
        },
        body: JSON.stringify(payloadFinal),
      });

      requestPromises.push(requestPromise);
    }

    // 3. 循环结束后，返回所有 Promise 组成的数组（供外部 Promise.all 使用）
    return requestPromises;
  ```
- ==解析==：首先在for循环中，每次调用fetch都是一次网络请求（异步），for循环速度很快，所以一瞬间会并发多个fetch网络请求，这些网络请求会返回promise对象（此时状态可能还在pending）， 这些对象存入数组返回出去
- promise.all会监听数组中promise对象的状态变化(fulfilled/rejected)，all方法的特性是当所有的promise都成功才会按顺序返回正确的结果，一旦一个失败，整体失败
## *copyFile(Sync)
- 把文件从一个地方复制到另一个地方，常用于提升目录，比如筛选特定的文件，然后统一放在一个新的目录中
- 最基础的用法： 
  ```js
    // 路径中包含文件的名字 例如 /user/data/img/apple.png
    fs.copyFileSync(sourcePath, targetPath);
  ```
  > 在本地获取好绝对路径后，包含文件名，之后会自动从旧地址sourcePath迁移至新地址targetPath
## *rmSync与unlinkSync
- 删除文件常用的api有`rmSync`和`unlinkSync`,其中`rmSync`是node 14+ 版本新增的更加高级的删除方法, ==推荐`rmSync`==
- 一、核心区别对比表
  | 特性                | `fs.unlinkSync(path)`                | `fs.rmSync(path, [options])`                          |
  |---------------------|---------------------------------------|-------------------------------------------------------|
  | **核心作用**        | 删除文件或符号链接（软链接）          | 删除文件、目录（空/非空）、符号链接（功能全覆盖）      |
  | **支持删除对象**    | 仅文件、软链接（删目录会报错）        | 文件、软链接、空目录、非空目录（需配置 `recursive: true`） |
  | **目录删除能力**    | 不支持（删目录抛 `ENOTDIR` 错误）     | 支持（空目录直接删，非空目录需加 `recursive: true`）  |
  | **强制删除**        | 不支持（文件占用时抛错）              | 支持（配置 `force: true`，忽略不存在路径/占用错误）   |
  | **新增特性**        | 无额外配置项，功能单一                | 支持递归删除、强制删除、同步异步兼容（对应 `rm` 命令） |
  | **Node.js 版本**    | 所有版本支持（传统方法）              | v14.14.0+ 支持（推荐使用，逐步替代 `unlinkSync`/`rmdirSync`） |
  | **底层关联**        | 对应 Unix 系统的 `unlink` 系统调用    | 对应 Unix 系统的 `rm` 命令（更贴近用户习惯）          |
  > ==软链接就是快捷方程式，它指向真正的文件存储位置，本身仅是个导航文件==
- 二、需求场景与推荐用法对应表
  | 需求场景                | 推荐使用                          | 不推荐/不支持                |
  |-------------------------|-----------------------------------|-----------------------------|
  | 删除单个文件            | `rmSync(path, { force: true })`   | `unlinkSync`（无容错）      |
  | 删除空目录              | `rmSync(path)`                    | `unlinkSync`（报错）        |
  | 删除非空目录            | `rmSync(path, { recursive: true, force: true })` | 无（需手动递归删）          |
  | 删除符号链接            | `rmSync` / `unlinkSync`           | -                           |
  | 兼容低版本 Node.js      | `unlinkSync`（文件）+ `rmdirSync`（空目录） | `rmSync`（版本不够）        |


- 删除文件/目录需要权限，设置好权限后，如下重置文件的操作
  ```js
    const testFile = path.join(__dirname, 'test.txt');
    const nonExistentFile = path.join(__dirname, 'nonexistent.txt');

    // 1.1 unlinkSync 删除文件（路径不存在会报错）
    try {
      fs.unlinkSync(testFile);
      console.log('unlinkSync：文件删除成功');
    } catch (err) {
      if (err.code === 'ENOENT') console.log('unlinkSync：文件不存在（报错）');
    }

    // 1.2 rmSync 删除文件（force: true 忽略不存在的路径，不报错）
    fs.rmSync(nonExistentFile, { force: true }); // 无报错
    console.log('rmSync：忽略不存在的文件，执行成功');

    // ==== 2.删除目录 仅rmSync ====

    // 2.1 rmSync 删空目录（直接删，无需额外配置）
    fs.rmSync(emptyDir);
    console.log('rmSync：空目录删除成功');

    // 2.2 rmSync 删非空目录（必须加 recursive: true，递归删除所有内容）
    fs.rmSync(nonEmptyDir, { recursive: true, force: true });
    console.log('rmSync：非空目录删除成功');
  ```
## *existsSync与statSync
- 1.existsSync： 用于判断路径是否存在，可以用来判断目录或文件是否存在，然后进行下一步操作
  ```js
    // 可以先判断文件夹是否存在
    if(!fs.existsSync(pathDir)){
      fs.mkdirSync(pathDir, { recursive: true })
    }
  ```
- 2.statSync：用于获取目录或文件的元数据,常用于检测文件的类型，或者获取文件基础信息
  ```js
    const stats = fs.statSync(filePath)

    // 1. 核心类型判断
    console.log('是否为文件：', stats.isFile()); // true
    console.log('是否为目录：', stats.isDirectory()); // false

    // 2. 大小与时间戳（格式化时间）
    console.log('文件大小：', stats.size, '字节（', (stats.size / 1024).toFixed(2), 'KB）');
    console.log('创建时间：', stats.birthtime.toLocaleString()); // 格式化本地时间
    console.log('最后修改时间：', stats.mtime.toLocaleString());
    console.log('最后访问时间：', stats.atime.toLocaleString());

    // 3. 解析文件权限（简单示例）
    const perm = stats.mode.toString(8).slice(-3); // 转换为 8 进制，取后 3 位（如 644）
    console.log('文件权限（8进制）：', perm); // 644 → 可读可写（所有者）、可读（其他）

    // 4. 所有者信息（Unix/mac 系统）
    console.log('所属用户 ID：', stats.uid);
    console.log('所属用户组 ID：', stats.gid);
  ```
## sharp的基础用法（待）
- 基础用法
  ```js
  /**
   * inputPath： 图片地址 （图片文件地址）
   * outputPath: 存放地址（文件夹）
   * quality: 图片质量
   */
    async function compressImage(inputPath, outputPath, quality = 80) {
      try {
        const ext = path.extname(inputPath).toLowerCase();
        const sharpInstance = sharp(inputPath);

        // 根据不同格式设置压缩参数
        switch (ext) {
          case ".jpg":
          case ".jpeg":
            await sharpInstance.jpeg({ quality }).toFile(outputPath);
            break;
          case ".png":
            await sharpInstance.png({ quality }).toFile(outputPath);
            break;
          case ".webp":
            await sharpInstance.webp({ quality }).toFile(outputPath);
            break;
          case ".gif":
            await sharpInstance.gif().toFile(outputPath); // gif格式不支持quality参数
            break;
          case ".tiff":
            await sharpInstance.tiff({ quality }).toFile(outputPath);
            break;
          default:
            throw new Error(`不支持的图片格式: ${ext}`);
        }

        console.log(`压缩成功: ${path.basename(inputPath)}`);
      } catch (error) {
        console.error(`压缩失败 ${path.basename(inputPath)}:`, error.message);
      }
    }
  ```
## 数组按类型分类
- ==经典算法，简单好用==
  ```js
    const info = [
      { folder: "Arrogant Girlfriend", file: "SsPczhbUIp.png", gender: 0 },
      { folder: "Arrogant Girlfriend", file: "SsPczh2wdp.png", gender: 0 },
      { folder: "Arrogant Girlfriend", file: "SsPcz2sxfp.png", gender: 0 },
      { folder: "Arrogant", file: "Sfcws2sxfp.png", gender: 0 },
      { folder: "Arrogant", file: "Sfcw2dxafp.png", gender: 0 },
      { folder: "Arrogant", file: "Sfcwswxhfp.png", gender: 0 },
      { folder: "Arrogant App", file: "Sfcw90xjhfp.png", gender: 0 },
      { folder: "Arrogant App", file: "Sfcw90xisfp.png", gender: 0 },
      { folder: "Arrogant App", file: "Scxjxopvhfp.png", gender: 0 },
    ];

    const result = {};

    // 按照folder划分
    function classfy(info) {
      info.forEach((item) => {
        const { folder, file, gender } = item;
        if (!result[folder]) {
          // 没有这个属性，添加这个属性
          result[folder] = [];
        }

        // 有这个属性后，直接追加
        result[folder].push({ file, gender });
      });
    }

    classfy(info);
    console.log("result", result);
  ```
## **多种遍历**
- ==总结下面几个==
  - for ... in
  - for ... of
  - entries
  - forEach
- 表格总结:
  | 特性                | for in                  | for of                  | entries() + 解构        | forEach()               |
  | :------------------ | :---------------------- | :---------------------- | :---------------------- | :---------------------- |
  | **遍历目标**        | 可枚举属性（对象/数组） | 可迭代对象（数组/字符串/Map/Set 等） | 可迭代对象（返回键值对） | 数组（含类数组 Array-like） |
  | **遍历内容**        | 键名（对象：属性名；数组：索引字符串） | 键值（数组元素/字符串字符/Map 值等） | [键名, 键值] 数组       | 数组元素 + 索引 + 原数组 |
  | **是否遍历原型链**  | 是（需手动过滤）        | 否（仅遍历自身可迭代内容） | 否                      | 否                      |
  | **是否可中断**      | 是（break/return）      | 是（break/return）       | 是（配合 for of）       | 否（return 仅跳过当前项，无法终止） |
  | **是否支持 await**  | 是（需在 async 函数中） | 是（需在 async 函数中） | 是（配合 for of）       | 否（回调中 await 无效，仅延迟当前项，不阻塞遍历） |
  | **是否修改原数据**  | 可（通过键名访问修改）  | 可（直接操作元素，引用类型生效） | 可（通过键值修改）       | 可（直接操作元素，引用类型生效） |
- 1.==for in==
- 常用遍历对象的键值对，主要功能是遍历对象的属性值
  ```js
    const obj = { a: 1, b: 2 };
    for (const key in obj) {
      // 过滤原型链属性（关键！）
      if (obj.hasOwnProperty(key)) {
        console.log(key, obj[key]); // 输出：a 1, b 2
      }
    }
  ```
  > 1.==obj.hasOwnProperty()方法==是检测此属性是不是obj自己本身的属性，返回布尔值，原因是for in方法会遍历当前对象及其原型链的所有属性，比如Object.prototype（对象原型）本来就有的toString join split方法等
  > 2.遍历数组不推荐，只会遍历出字符串格式的索引字段
- 2.==for of==
- 遍历可迭代对象（数组、字符串、Map、Set、Generator 等）的值，不关心索引
- ==不支持直接对对象遍历,需要Object.entries()转化==
  ```js
    // 遍历数组（推荐）
    const arr = [1, 2, 3];
    for (const val of arr) {
      if (val === 2) break; // 可中断
      console.log(val); // 输出：1
    }

    // 遍历字符串
    const str = "abc";
    for (const char of str) {
      console.log(char); // 输出：a, b, c
    }

    // 遍历 Map（天然遍历 [key, value]）
    const map = new Map([["a", 1], ["b", 2]]);
    for (const [key, val] of map) {
      console.log(key, val); // 输出：a 1, b 2
    }
  ```
- ==3.entries方法 -- 遍历键值对==
- entries() 是可迭代对象的方法（数组、Map 原生支持，==对象需用Object.entries()==）
  ```js
    // 特殊地，对象没有entries方法，需要通过Object.entries()把对象先转化为可迭代对象
    const obj2 = { a: 1, b: 2 };
    console.log(Object.entries(obj2)); // -> [ [ 'a', 1 ], [ 'b', 2 ] ]
    for (const [key, value] of Object.entries(obj2)) {
      console.log("key", key, "value", value);
    }

    // 数组 Map等数据直接调用 entries方法即可
    // 数组 entries()：键是索引（数字），值是元素
    const arr3 = [1, 2];
    for (const [index, val] of arr3.entries()) {
      console.log(index, val); // 输出：0 1, 1 2
    }
    // Map entries()：原生返回 [key, value]（与 for of 天然契合）
    const map = new Map([["a", 1]]);
    for (const [key, val] of map.entries()) {
      // 可简写为 for (const [key, val] of map)
      console.log(key, val); // 输出：a 1
    }
  ```
- ==4.forEach==
- 不支持异步，不支持中断（仅跳过）
  ```js
    // 值，索引（从1开始），原数组（即arr，可以用来修改原数组的值）
    const arr4 = [1, 2, 3];
    arr4.forEach((val, index, originalArr) => {
      console.log(val, index); // 输出：1 0, 2 1, 3 2
      // return 仅跳过当前项，无法终止遍历
      if (val === 2) return;
    });
  ```
## sort 
- 针对数组的排序操作，业务上纯数组情况比较少，一般是对象数组的操作
  ```js
    // 常用的sort排序问题
    // 只能对数组进行排序，如下
    // 1. 数字数组按大小排序
    const nums = [10, 2, 5];
    nums.sort((a, b) => a - b); // 升序：[2, 5, 10]
    nums.sort((a, b) => b - a); // 降序：[10, 5, 2]

    // 2. 对象数组按属性排序（常用场景）
    const users = [
      { name: "张三", age: 25 },
      { name: "李四", age: 20 },
      { name: "王五", age: 30 },
    ];
    // 按 age 升序排序
    users.sort((a, b) => a.age - b.age);
    console.log(users);
    // 结果：[{name: '李四', age:20}, {name: '张三', age:25}, {name: '王五', age:30}]
  ```
- ==针对对象，也可以通过entries等操作把它转化为对象数组格式==
  ```js
    /**
     * 针对2，有的时候可以对象转化成符合要求的数组格式
    */

    const data = {
      Karina: [1763799551640],
      "Renee Miller": [1763826770126, 1763869100958, 1764256528002],
      "Red Rex": [1763851722957],
      Elizabeth: [1763855662650],
      Hana: [1763878207592],
      Gen2: [1764104808656],
      Haley: [1764317594871],
    };

    const dataArr = Object.entries(data)
      .map(([name, tsArr]) => ({ name, tsArr }))
      .sort((a, b) => {
        if (a.tsArr.length !== b.tsArr.length) {
          return b.tsArr.length - a.tsArr.length; // 数量不一致根据根据ts排
        } else {
          return a.name - b.name; // 数量一致，按照名字排（字符串编码）
        }
      });
    /** 经过map操作后，sort根据数组长度进行排序了
    * [
      { name: 'Karina', tsArr: [ 1763799551640 ] },
      {
        name: 'Renee Miller',
        tsArr: [ 1763826770126, 1763869100958, 1764256528002 ]
      },
      { name: 'Red Rex', tsArr: [ 1763851722957 ] },
      { name: 'Elizabeth', tsArr: [ 1763855662650 ] },
      { name: 'Hana', tsArr: [ 1763878207592 ] },
      { name: 'Gen2', tsArr: [ 1764104808656 ] },
      { name: 'Haley', tsArr: [ 1764317594871 ] }
    ]
    */
    console.log(dataArr);
  ```
## switch定义与作用域
- 作用域导致无法重定义，而直接使用不定义又会有未定义使用变量的小问题
  ```js
    // switch的定义与作用域问题
    switch (chartType) {
      case "Line":
        let xAxisData = this.lineData.map((item) => String(item.day));
        let lineOps = {
          xAxis: {
            type: "category",
            data: xAxisData,
          },
        };

        lineOps && this.lineEchart.setOption(lineOps, true); // 增加true参数，强制更新
        break;
      case "multiLine":
        // ❌：switch的{}中，公用一个作用域，所以这里xAxisData是不能与case Line（1）重名的
        // ❌：误区：case multiLine中不能直接使用xAx，因为虽然解决了作用域矛盾，但是代码在switch中是依照case分支执行的，如果进入case 2分支，就会出现xAx未定义的问题，因为它只在case 1中定义，case 2中未定义
        // 所以遇到这种case 1和2都需要同一个变量，但是作用域和定义问题出现矛盾的问题，解决是统一在switch外部定义xAx,内部直接使用即可
        // let xAxisData = this.lineData.map((item) => String(item.day));
        let multiLinesOps = {
          xAxis: {
            type: "category",
            data: xAxisData,
          },
        };
        multiLinesOps && this.multiLinesEchart.setOption(multiLinesOps, true); // 增加true参数，强制更新
        break;
      default:
        new Error("未知的Echart类型");
    }

    // 解决: ✅ 统一在switch外部定义xAx,内部直接使用
    let xAxisData = 11111;
    switch (a) {
      case 1:
        let lineOps = {
          xAxis: {
            type: "category",
            data: xAxisData,
          },
        };
        break;
      case 2:
        let multiLinesOps = {
          xAxis: {
            type: "category",
            data: xAxisData,
          },
        };
        break;
    }


  ```

## 下载json文件
- 下载json文件，豆包出品，已测试可用
  ```js
    /**
     * 导出 JSON 文件并下载
    * @param {Object|Array} data 要导出的数据（对象/数组）
    * @param {string} filename 下载的文件名（无需 .json 后缀）
    */
    export function downloadJson(data, filename = "导出数据") {
      try {
        // 1. 将数据转为 JSON 字符串（ensureAscii: false 支持中文）
        const jsonStr = JSON.stringify(data, null, 2); // 第三个参数 2 是格式化缩进，可读性更好

        // 2. 构造 Blob 对象（文件流），指定 MIME 类型为 application/json
        const blob = new Blob([jsonStr], {
          type: "application/json; charset=utf-8",
        });

        // 3. 创建临时下载链接
        const url = URL.createObjectURL(blob);

        // 4. 创建 <a> 标签触发下载
        const a = document.createElement("a");
        a.href = url;
        // 处理中文文件名（encodeURIComponent 避免乱码）
        a.download = `${encodeURIComponent(filename)}.json`;
        a.style.display = "none"; // 隐藏标签

        // 5. 触发点击下载，然后移除临时链接（避免内存泄漏）
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // 释放 Blob URL
      } catch (error) {
        console.error("JSON 导出失败：", error);
        alert("导出失败，请重试！");
      }
    }
  ```
## 睡眠与轮询
- 睡眠函数，简单的应用如下
  ```js
    // 睡眠函数，暂停x ms后继续执行
    // Promise 构造函数需要传入一个执行函数，这个函数默认有两个参数：resolve（成功回调）和 reject（失败回调）。这里只写了 r，是 resolve 的简写（程序员常用的缩写方式）。
    // 简单说：r 就是一个 “开关”，调用 r() 就表示这个 Promise 从 “等待” 状态变成 “成功完成” 状态。
    // setTimeout 是 JS 原生的定时器，作用是 “延迟指定毫秒后执行第一个参数的函数”。
    // 这里的逻辑是：等待 ms 毫秒后，自动调用 r()（也就是触发 Promise 的成功状态）。
    const sleep = (ms) => new Promise((r) => setTimeout(r, 2000));

    (async () => {
      console.log("1");
      await sleep();
      console.log("2");
    })();
  ```
- 简单的轮询
  ```js
    // 应用： 比如ai生图，ai生图的任务下达后，并不会立即生成，需要通过轮询反复查看任务执行情况（成功/等待/失败），然后返回对应结果

    // 注意fetch和axios对请求的结果处理是不同的，axios经过封装后仅需.data即可获取，2而fetch需要先转化下格式.json 异步）
    // 最大尝试30次，每次间隔3000秒
    const sleep = (ms) => new Promise((r) => setTimeout(r, 2000));
    async function pollTask(opts, maxAttemps = 30, interval = 3000) {
      for (let attmps = 0; attmps < maxAttemps; attmps++) {
        const response = await fetch("/", opts);
        const result = await response.json(); // 与axios有所不同

        // state是返回的参数，用来鉴别是否有结果了
        if (result.state === "success") {
          const results = JSON.parse(result); // 需要解析json字符串为js对象
          console.log("success任务完成");
          return results;
        }

        if (result.state === "fail") {
          console.log("任务失败", result.failMsg);
          throw new Error(failMsg);
        }

        await sleep(interval);
      }

      throw new Error("pollTask任务在最大尝试次数(30)后超时");
    }
  ```
